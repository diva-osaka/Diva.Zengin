using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Diva.Zengin.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class IndexToLengthMapGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("IndexToLengthMapAttribute.cs",
                """
                namespace Diva.Zengin;

                using System;

                [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                internal sealed class IndexToLengthMapAttribute : Attribute
                {
                }
                """);
            context.AddSource("IIndexToLengthMap.cs",
                """
                namespace Diva.Zengin.Formats;
                
                public interface IIndexToLengthMap
                {
                    static abstract SortedDictionary<int, int> GetIndexToLengthMap();
                }
                """);
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Diva.Zengin.IndexToLengthMapAttribute",
            static (node, token) => node is ClassDeclarationSyntax,
            static (context, token) => context);

        context.RegisterSourceOutput(source, Emit);
    }

    private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var classSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var classNode = (ClassDeclarationSyntax)source.TargetNode;

        var properties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic);

        var indexToLengthMap = new Dictionary<int, int>();

        foreach (var property in properties)
        {
            var indexAttr = property.GetAttributes()
                .FirstOrDefault(attr => attr.AttributeClass?.Name == "IndexAttribute");

            if (indexAttr == null)
                continue;

            var index = (int)indexAttr.ConstructorArguments[0].Value!;
            var length = 1; // default length

            var typeConverterAttr = property.GetAttributes()
                .FirstOrDefault(attr => attr.AttributeClass?.Name == "TypeConverterAttribute");

            if (typeConverterAttr != null)
            {
                var converterType = (INamedTypeSymbol)typeConverterAttr.ConstructorArguments[0].Value!;
                var typeName = converterType.Name;

                if (typeName.Contains("JapaneseEraDateTypeConverter"))
                {
                    length = 6;
                }
                else if ((typeName.Contains("NumberTypeConverter") || typeName == "CharacterTypeConverter") &&
                         typeConverterAttr.ConstructorArguments.Length > 1)
                {
                    var lengthArg = typeConverterAttr.ConstructorArguments[1];
                    if (lengthArg.Kind == TypedConstantKind.Array)
                    {
                        length = lengthArg.Values.Select(v => (int)v.Value!).First();
                    }
                    else
                    {
                        length = (int)lengthArg.Value!;
                    }
                }
            }

            indexToLengthMap[index] = length;
        }

        var mapEntries = string.Join(", ", indexToLengthMap.Select(kv => $"{{{kv.Key}, {kv.Value}}}"));
        var mapCode = $"new SortedDictionary<int, int> {{ {mapEntries} }}";

        var ns = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {classSymbol.ContainingNamespace};";

        var code = $$"""
                     // <auto-generated/>

                     {{ns}}

                     partial class {{classSymbol.Name}} : IIndexToLengthMap
                     {
                         public static SortedDictionary<int, int> GetIndexToLengthMap() => {{mapCode}};
                     }
                             
                     """;

        context.AddSource($"{classSymbol.Name}.IndexToLengthMap.g.cs", SourceText.From(code, Encoding.UTF8));
    }
}