using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Diva.Zengin.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class TypeConverterGetterGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("TypeConverterGetterAttribute.cs",
                """
                namespace Diva.Zengin;

                using System;

                [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                internal sealed class TypeConverterGetterAttribute : Attribute
                {
                }
                """);
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Diva.Zengin.TypeConverterGetterAttribute",
            static (node, token) => true,
            static (context, token) => context);

        context.RegisterSourceOutput(source, Emit);
    }

    private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;

        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {typeSymbol.ContainingNamespace};";

        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");

        var publicProperties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public &&
                        p is { IsStatic: false, GetMethod: not null });

        var methods = new System.Collections.Generic.List<string>();

        foreach (var property in publicProperties)
        {
            var typeConverterAttr = property.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "TypeConverterAttribute");

            if (typeConverterAttr == null)
                continue;

            string? converterTypeName = null;
            int? countParameter = null;

            if (typeConverterAttr.ConstructorArguments.Length > 0)
            {
                var firstArg = typeConverterAttr.ConstructorArguments[0];
                if (firstArg.Value is INamedTypeSymbol typeArgSymbol)
                {
                    // ジェネリック型引数を含む型名を取得
                    converterTypeName = typeArgSymbol.ToDisplayString(new SymbolDisplayFormat(
                        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameOnly,
                        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters));
                }
            }

            if (typeConverterAttr.ConstructorArguments.Length > 1)
            {
                var secondArg = typeConverterAttr.ConstructorArguments[1];
                if (secondArg is { Kind: TypedConstantKind.Array, Values.Length: > 0 } &&
                    secondArg.Values[0].Value is int intValue)
                {
                    countParameter = intValue;
                }
            }

            if (converterTypeName == null)
                continue;

            var propertyName = property.Name;
            var methodBody = countParameter.HasValue
                ? $"return (new Diva.Zengin.Converters.{converterTypeName}({countParameter.Value})).ConvertToString(this.{propertyName}, null, null);"
                : $"return (new Diva.Zengin.Converters.{converterTypeName}()).ConvertToString(this.{propertyName}, null, null);";

            var method = $$"""
                           /// <summary>
                           /// <see cref="{{propertyName}}"/>の値を全銀協フォーマットの桁数で取得します。
                           /// </summary>
                           public string Get{{propertyName}}()
                           {
                               {{methodBody}}
                           }
                           """;

            methods.Add(method);
        }

        if (methods.Count == 0)
            return;

        var indentedMethods = string.Join("\n\n", methods)
            .Split('\n')
            .Select(line => string.IsNullOrWhiteSpace(line) ? line : "    " + line)
            .Aggregate((current, next) => current + "\n" + next);

        var code = $$"""
                     // <auto-generated/>
                     #nullable enable
                     #pragma warning disable CS8600
                     #pragma warning disable CS8601
                     #pragma warning disable CS8602
                     #pragma warning disable CS8603
                     #pragma warning disable CS8604
                     #pragma warning disable CS8625

                     {{ns}}

                     partial class {{typeSymbol.Name}}
                     {
                     {{indentedMethods}}
                     }
                     """;

        context.AddSource($"{fullType}.TypeConverterGetter.g.cs", code);
    }
}